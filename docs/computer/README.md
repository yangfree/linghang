---
title: 计算机基础
sidebar: auto
pageClass: my-computer
---

## 网络 IO 模型变迁

我们最常见的服务器程序一般是基于 `HTTP` 和 `TCP` 协议来提供服务的， `HTTP` 底层又基于`TCP` ，所以我们直接来描述 `TCP` 协议在服务器端实现的逻辑。在操作系统中 `TCP` 的通信过程又被称之为**网络IO**操作，下面描述的就是网络IO操作的简史。

`TCP` 服务在建立完 `socket` 监听后，会调用 `accept()` 函数来监听客户端的连接请求，但是这个过程是堵塞的。也就是说如果函数没有返回，当前线程会一直等待，而且在这个等待的过程中无法做任何事情。伪代码如下：

``` js
while (true) {
    socket = accept();
}
```

我们通过 `accept` 函数，服务器和客户端之间建立了一个 `socket` 连接，建立完连接之后，就可以开始发送接收数据的操作。但是当程序运行到 `accept` 函数的时候，是堵塞的，也就是说这个函数不运行完成，代码是没法继续运行的。 假设我们现在 `accept` 函数返回了，那么我们就可以读取这个连接发送过来的请求数据了：

``` js
while (true) {
    socket = accept();
    while (true) {
        data = read(socket);
        //process_data(data); //处理数据
    }
}
```

不过和 ` accept` 一样，这个 `read ` 函数依然是堵塞的。照这个趋势下去，一个服务器只能给一个连接做服务了，其他的连接就干等着。这可不是我们想要的结果。

我们的前辈们想到的解决方案是 `fork` 子进程，每次跟客户端建立一个连接，都创建一个新的子进程来维护当前连接，在这个新的子进程中进行发送和接收数据。这种子进程的模型的典型代表就是 `Apache 1.x。` 我们来看一下伪代码：

``` JS
while (true) { //主进程代码
    socket = accept();
    var child = fork(socket);
}
while (true) { //子进程代码
    data = read(socket);
}
```

看上去是一个好的解决方案，各个`socket`连接在读取数据的时候都是在单独的一个进程中完成的，不会互相堵塞。不过进程的创建是一个耗时的操作，而且操作系统对于启动的最大进程数也是有限制的，如果服务器创建大量线程，有可能导致系统其他进程无法启动(所以一般服务器都会限制启动子进程的最大数目，这个时候在程序里面会维护一个`socket`队列，来决定那些连接被丢入子进程进行处理。)。这个时候线程便进入了大家的视野，它作为`cpu`的最小调度单位，具有比进程更少的资源占用，最好的性能。线程有进程创建，对于一个进程来说，它所创建的线程共享其内存数据，且可以被统一管理。Apache 从2.x开始增加了对多线程的支持。

即使使用了线程，但是计算机的`CPU`每次可以处理的线程数是有限的（单核`CPU`每次处理一个线程，双核可以同时处理两个，`Intel`使用超线程技术，可以使一个核心处理两个线程，所以说我们常用的i5处理器，虽然是两核但是却可以同时处理四线程），为了让各个线程公平对待，`CPU`在单位时间内会切换正在处理的线程。但是这个切换动作是比较耗时的，`CPU`在将处理的线程任务切换走之前要暂存线程的内存，在切换入一个新的要处理的进程之前要读取之前暂存的线程内存，当然还要考虑到`CPU`内部还要有一套调度算法，来决定什么时候将线程切换到`CPU`进行处理。所以说使用线程也会遇到性能瓶颈，不会像我们想的那样，线程数起的越多，性能越好。

我们把`socket`通讯过程类比为你在淘宝上买东西的过程，你在淘宝上下单买了件商品（`socket`连接建立了）。对于堵塞 `IO` 来说，你需要给快递员打电话，并且你还不能挂断，在快递员没有通知你商品到之前，你啥事也不能干。

在真实场景中，用户就是你的应用程序，而快递员就是你的 `Linux` 内核。对于非堵塞 `IO` 来说，为了了解到包裹是否送达了，你只需要定时给快递员打电话咨询。不过
你在打完电话之后还可以忙别的，比如说看会儿书，喝喝茶。然后你想起来，我靠还有一个快递呢，于是赶紧再打一个电话，结果发现人家快递员已经在楼下等了半天。所以说，要想尽早得到快递，你得一直跟快递员打电话。

有人问，为什么不是快递员给你打电话，而是你给快递员打电话，首先声明一下，为了简化描述的工作量，我们现在先按照`linux`操作系统来讲，`在linux`系统中只能用户去调用内核函数，没有内核函数主动通知用户程序的功能。我们这里内核函数就是快递员，用户程序就是你自己，所以只能你自己打电话给快递员。同时大家需要注意，对于非堵塞`IO` 这个定义，有不同的叫法，有的管我们刚才提到的这种方式交非堵塞 `IO `，但是有的管 `IO` 多路复用 （下面马上讲）叫非堵塞 `IO`。

OK，下面要轮到我们的 `IO` 多路复用闪亮登场了。 一般你在淘宝上买东西，填写邮寄方式的时候，都是直接写你自己的地址，不过淘宝其实提供了菜鸟驿站这个东西，你可以在不方便的情况下把，把包裹的邮寄地址写成菜鸟驿站。这个样子你的所有快递就都可以由菜鸟驿站来代收了，不过你仍然要打电话询问驿站的工作人员，快递来了吗（因为我们用的是`linux`，在这个操作系统下，内核是不会主动通知用户程序的，这个步骤在`linux`中称为事件查询）。

回到上面的栗子，你可能会问如果单纯一件商品的话，自己直接等快递显然比先送到菜鸟驿站再打电话问要快。是的，没错！但是不要忘了，为了收多件快递，每订购一件商品，都要克隆出另外一个你（`fork`子进程或者创建线程），来等着收快递，一旦你淘宝上下单量很大，管理这些克隆人的成本就会陡增（主要耗费在进程或线程的上下文切换和调度）。所以说在连接数不大的情况下使用堵塞`IO`反而效率更高。

这个`IO` 多路复用在`linxu`上几经更新，发展到现在，使用的最新技术就是 `epoll` ，`nginx` 底层就是利用了这个技术。其实通过前面的栗子，我们发现 `IO `多路复用中依然有堵塞过程（不断打电话给菜鸟驿站的过程），不过实际上` epoll` 等 `API` 提供的事件查询函数默认调用完成后立即返回（即使没有任何事件，也立即返回），基本可以忽略堵塞时间（当然也支持在事件查询的时候设置超时时间，在超时时间内没有事件产生就一直堵塞）。

### Tcp传输对三次握手和四次挥手策略

为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。

发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。

> 断开一个TCP连接则需要“四次握手”：

第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。

第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。

第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。

第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

### TCP和UDP的区别

TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来。

UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。

## 渐进增强和优雅降级

- 渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
- 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
